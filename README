// Memory addressing


	The general idea of my code to solve the tasks was to use structured data,
string operations, and memory addressing. Also, conditional and unconditional jumps
were used within looping instructions, etc.

					IMPLEMENTATION

1. ROTP	- I have created a label that acts as a for loop (also 
	  having the meaningful name "loop"). Here, as it is required,
	  I performed a XOR between the byte from the current step in
	  the plaintext and the byte from the current step in the reversed
	  key. The result is put into the cyphertext, and the process is
	  repeated until the length len is reached;

2. Ages	- Here too, the whole process takes place in a loop whose label is
	  called "loop". Initially, I compare the current year with
	  the teammate's birth year. If the current year is less than or equal
	  to the birth year, then the teammate's age is 0 and we move on.
	  Otherwise, we will find out the teammate's "provisional" age by
	  taking the difference. It is a provisional age, because there will be
	  cases in which the current teammate's birth month/day is greater than
	  the current month/day and thus we will have to decrement the age,
	  since it is not yet complete. These cases are handled in the monthle,
	  monthequal, dayless labels. Additional comments are added in the source
	  for a clearer understanding of the code;

3. Columnar - In the current_column_idx tag we will determine the column in the
	      matrix that must be traversed at the current step, it being placed
	      in the edx register. Further, with the help of edx we will get the
	      byte from the haystack that must be put in the ciphertext. Next, we
	      add the key length to edx and thus we will be able to simulate the
	      traverse from line to line of the current column. This addition of
	      the key length to edx is repeated until we exceed the length of the
	      haystack. When we have exceeded, we move to the next column specified
	      by the order vector.